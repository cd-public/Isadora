README:

- Research notes - 

The always and never tainted registers are in *_ts.out

The conditionally tainted registers are present in *.spinfo. They are listed in daikon readable format, but for line

     0==orig(shadow_AW_ADDR_VALID) && 0!=shadow_AW_ADDR_VALID

the conditionally tainted register is 

     AW_ADDR_VALID.

- Github Notes -

Directories:

. : Main research working directory

CT : C(alvin)T(est) - experimental directory for working on custom sourced traces 

Files:

2pass.py : IFT trace miner front end interface for Daikon using the "2 pass" methodology of mining for preconditions then mining with preconditions. Used to generate *.out

refine_vcd.py : Utility script to convert Tortuga output VCDs to smaller files to keep under version control. Used to generate r_*.vcd

*.vcd : Traces generated by Tortuga and refined by refine_vcd, the input to 2pass.py

*_n.* : temporary files created by 2pass.py in process of generating *.out, n denotes which pass files were generated in

*.decls : daikon declarations file, internal temp file generated by 2pass.py from *.vcd, gives registers composed into properties, paired with a .dtrace

*.dtrace : daikon trace file, internal temp file generated by 2pass.py from *.vcd, encodes VCD in daikon readable form

*.spinfo : daikon split info file, internal temp file generated by 2pass.py from *.vcd, specifies precondition for daikon properties of form "<precondition> -> <expression>"

*.out : output files. *_ts.out gives always/never/conditionally tainted registers, <reg_name>.out gives conditions under which <reg_name> is conditionally tainted, all others 2pass.py internals

readme.txt : this file

do_fabricant.txt : cached batch file for trace generation on fabricant

